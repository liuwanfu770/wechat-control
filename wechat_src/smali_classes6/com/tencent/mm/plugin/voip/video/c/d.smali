.class public final Lcom/tencent/mm/plugin/voip/video/c/d;
.super Ljava/lang/Object;
.source "SourceFile"


# annotations
.annotation runtime Lf/l;
    gPh = {
        0x1,
        0x1,
        0x10
    }
    gPi = {
        "\u0000R\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\u0008\u0002\n\u0002\u0010\u0008\n\u0002\u0008\u0004\n\u0002\u0018\u0002\n\u0002\u0008\u0004\n\u0002\u0018\u0002\n\u0002\u0008\u0005\n\u0002\u0010\u000b\n\u0000\n\u0002\u0010\u0002\n\u0002\u0008\u0004\n\u0002\u0018\u0002\n\u0002\u0008\u0003\n\u0002\u0018\u0002\n\u0002\u0008\u0004\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0008\u0005\u0018\u00002\u00020\u0001B\u0005\u00a2\u0006\u0002\u0010\u0002J\u0006\u0010\u0015\u001a\u00020\u0016JF\u0010\u0017\u001a\u00020\u00162\u0006\u0010\u0018\u001a\u00020\u00042\u0006\u0010\u0019\u001a\u00020\u00042\u0006\u0010\u001a\u001a\u00020\u001b2\u0006\u0010\u001c\u001a\u00020\u001b2\u0006\u0010\u001d\u001a\u00020\u00042\u0006\u0010\u001e\u001a\u00020\u001f2\u0006\u0010 \u001a\u00020\u00042\u0006\u0010!\u001a\u00020\u0014J0\u0010\"\u001a\u00020\u00162(\u0010#\u001a$\u0012\u0004\u0012\u00020%\u0012\u0004\u0012\u00020\u0004\u0012\u0004\u0012\u00020\u0004\u0012\u0004\u0012\u00020\u0004\u0012\u0004\u0012\u00020\u00160$j\u0002`&J\u001e\u0010\'\u001a\u00020\u00162\u0006\u0010(\u001a\u00020\u00042\u0006\u0010)\u001a\u00020\u00042\u0006\u0010*\u001a\u00020\u0004R\u000e\u0010\u0003\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0005\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0006\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0007\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u0010\u0010\u0008\u001a\u0004\u0018\u00010\tX\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\n\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u000b\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u000c\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u0010\u0010\r\u001a\u0004\u0018\u00010\u000eX\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u000f\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0010\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0011\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0012\u001a\u00020\u0004X\u0082\u000e\u00a2\u0006\u0002\n\u0000R\u000e\u0010\u0013\u001a\u00020\u0014X\u0082\u0004\u00a2\u0006\u0002\n\u0000\u00a8\u0006+"
    }
    gPj = {
        "Lcom/tencent/mm/plugin/voip/video/programv2/VoipMMFaceBeautyRendererProgram;",
        "",
        "()V",
        "attributePosition",
        "",
        "attributeTextureCoord",
        "brightnessUniform",
        "programId",
        "renderProc",
        "Lcom/tencent/mm/media/render/proc/GLTextureRenderProcTexture;",
        "showCounterUniform",
        "showModeUniform",
        "smoothDegreeUniform",
        "surfaceOut",
        "Lcom/tencent/mm/plugin/voip/video/render/EncoderSurfaceRender;",
        "texelHeightUniform",
        "texelWidthUniform",
        "uniformMatrix",
        "uniformTexture",
        "useGpuConvert",
        "",
        "release",
        "",
        "renderImpl",
        "drawWidth",
        "drawHeight",
        "cubeBuffer",
        "Ljava/nio/FloatBuffer;",
        "textureCoordBuff",
        "texture",
        "outputTexture",
        "Lcom/tencent/mm/media/globject/GLTextureObject;",
        "encodeRotate",
        "encodeMirror",
        "setFaceBeautyDataCallback",
        "callback",
        "Lkotlin/Function4;",
        "Ljava/nio/ByteBuffer;",
        "Lcom/tencent/mm/plugin/voip/video/program/FaceBeautyDataCallBack;",
        "updateEncodeResType",
        "encWidth",
        "encHeight",
        "encoderType",
        "plugin-voip_release"
    }
.end annotation


# instance fields
.field public ECK:I

.field public ECL:I

.field public ECM:I

.field public ECN:I

.field public ECO:I

.field public ECP:I

.field public EEr:Lcom/tencent/mm/plugin/voip/video/render/EncoderSurfaceRender;

.field public final EEs:Z

.field public gRA:I

.field public gRB:I

.field public gRC:I

.field public gRz:Lcom/tencent/mm/media/j/b/e;

.field public programId:I


# direct methods
.method public constructor <init>()V
    .locals 12

    .prologue
    const v11, 0x372b1

    const v10, 0x47012f00    # 33071.0f

    const v9, 0x46180400    # 9729.0f

    const v8, 0x8d65

    const/4 v1, 0x0

    .line 17
    invoke-direct {p0}, Ljava/lang/Object;-><init>()V

    invoke-static {v11}, Lcom/tencent/matrix/trace/core/AppMethodBeat;->i(I)V

    .line 32
    sget-object v0, Lcom/tencent/mm/plugin/voip/b/g;->EyF:Lcom/tencent/mm/plugin/voip/b/g;

    invoke-static {}, Lcom/tencent/mm/plugin/voip/b/g;->faY()Z

    move-result v0

    iput-boolean v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->EEs:Z

    .line 34
    sget-object v0, Lcom/tencent/mm/media/k/c;->hwV:Lcom/tencent/mm/media/k/c$a;

    const-string/jumbo v0, "\n        attribute vec4 a_position;\n        attribute vec2 a_texCoord;\n        varying vec2 v_texCoord;\n        void main() {\n            gl_Position = a_position;\n            v_texCoord = a_texCoord;\n        }\n        "

    const-string/jumbo v2, "\n                    #extension GL_OES_EGL_image_external : require\n                    varying highp vec2 v_texCoord;\n                    uniform samplerExternalOES inputImageTexture;\n                    uniform mediump float smoothDegree;\n                    uniform mediump int showCounter;\n                    uniform mediump int showMode;\n                    uniform mediump float brightness;\n                    uniform mediump float texelWidth;\n                    uniform mediump float texelHeight;\n                    precision highp float;\n                    const mat3 RGBtoYUV = mat3(0.299,  0.587, 0.114, 0.5, -0.4187, -0.0813, -0.169, -0.3313,  0.5 );    //full range\\n\" +\n                    const mat3 YUVtoRGB = mat3(1.1643, 1.5958, 0.0, 1.1643, -0.8129, -0.3917, 1.1643, 0.0, 2.017 );\n                    const highp mat3 saturateMatrix = mat3(\n                    1.1102, -0.0598, -0.061,\n                    -0.0774, 1.0826, -0.1186,\n                    -0.0228, -0.0228, 1.1772);\n                    vec3 rgb2hsv(vec3 c) {\n                        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n                        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n                        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n                        float d = q.x - min(q.w, q.y);\n                        float e = 1.0e-10;\n                        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n                    }\n                    vec3 hsv2rgb(vec3 c) {\n                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n                    }\n\n                    vec3 yuv2rgb(vec3 c) {\n                        vec3 rgb = YUVtoRGB*c;\n                        return rgb;\n                    }\n                    vec3 rgb2yuv(vec3 c) {\n                        vec3 yuv = c*RGBtoYUV;\n                        return yuv;\n                    }\n                    mediump float hardLight(mediump float color) {\n                        if (color <= 0.5)\n                        color = color * color * 2.0;\n                        else\n                        color = 1.0 - ((1.0 - color)*(1.0 - color) * 2.0);\n                        return color;\n                    }\n                    float lum(vec3 v) {\n                        return dot(v, vec3(0.299, 0.587, 0.114));\n                    }\n\n                    vec4 getValue(vec4 newValue, vec4 originValue) {\n                        return mix(newValue, originValue, step(lum(newValue.rgb), lum(originValue.rgb)));\n                    }\n                    vec4 Sobel2() {\n                        vec2 samplerSteps = vec2(1.0/texelWidth, 1.0/texelHeight);\n                        vec2 coords[8];\n                        coords[0] = v_texCoord - samplerSteps * 2.0;\n                        coords[1] = v_texCoord + vec2(0.0, -samplerSteps.y) * 2.0;\n                        coords[2] = v_texCoord + vec2(samplerSteps.x, -samplerSteps.y) * 2.0;\n                        coords[3] = v_texCoord - vec2(samplerSteps.x, 0.0) * 2.0;\n                        coords[4] = v_texCoord + vec2(samplerSteps.x, 0.0) * 2.0;\n                        coords[5] = v_texCoord + vec2(-samplerSteps.x, samplerSteps.y) * 2.0;\n                        coords[6] = v_texCoord + vec2(0.0, samplerSteps.y) * 2.0;\n                        coords[7] = v_texCoord + vec2(samplerSteps.x, samplerSteps.y) * 2.0;\n                        vec3 colors[8];\n                        for(int i = 0; i < 8; ++i) {\n                            colors[i] = texture2D(inputImageTexture, coords[i]).rgb;\n                        }\n                        vec4 src = texture2D(inputImageTexture, v_texCoord);\n                        vec3 h = -colors[0] - 2.0 * colors[1] - colors[2] + colors[5] + 2.0 * colors[6] + colors[7];\n                        vec3 v = -colors[0] + colors[2] - 2.0 * colors[3] + 2.0 * colors[4] - colors[5] + colors[7];\n                        return vec4(mix(src.rgb, sqrt(h * h + v * v), 1.0), src.a);\n                    }\n                    vec4 maxFilter() {\n                        vec2 samplerSteps = vec2(1.0/texelWidth, 1.0/texelHeight);\n                        vec2 texCoord[13];\n                        vec4 vMin;\n                        vec2 thisCoord = v_texCoord;\n                        texCoord[0] = thisCoord + vec2(0, -samplerSteps.y * 2.0);\n                        texCoord[1] = thisCoord - samplerSteps;\n                        texCoord[2] = thisCoord + vec2(0, -samplerSteps.y);\n                        texCoord[3] = thisCoord + vec2(samplerSteps.x, -samplerSteps.y);\n                        texCoord[4] = thisCoord + vec2(-samplerSteps.x * 2.0, 0.0);\n                        texCoord[5] = thisCoord + vec2(-samplerSteps.x, 0.0);\n                        texCoord[6] = thisCoord;\n                        texCoord[7] = thisCoord + vec2(samplerSteps.x, 0.0);\n                        texCoord[8] = thisCoord + vec2(samplerSteps.x * 2.0, 0.0);\n                        texCoord[9] = thisCoord + vec2(-samplerSteps.x, samplerSteps.y);\n                        texCoord[10] = thisCoord + vec2(0.0, samplerSteps.y);\n                        texCoord[11] = thisCoord + samplerSteps;\n                        texCoord[12] = thisCoord + vec2(0.0, 2.0* samplerSteps.y);\n                        {\n                            vec4 vTemp;\n                            vMin = texture2D(inputImageTexture, texCoord[0]);\n                            vTemp = texture2D(inputImageTexture, texCoord[1]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[2]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[3]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[4]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[5]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[6]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[7]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[8]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[9]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[10]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[11]);\n                            vMin = getValue(vTemp, vMin);\n                            vTemp = texture2D(inputImageTexture, texCoord[12]);\n                            vMin = getValue(vTemp, vMin);\n                        }\n                        return vMin;\n                    }\n\n                    void main() {\n                        highp vec3 yuv;\n                        highp vec3 rgb;\n                        vec3 centralColor = texture2D(inputImageTexture,  v_texCoord).rgb;\n                        vec2 blurCoordinates[20];\n                        vec2 imageStep = vec2(1.5/texelWidth, 1.5/texelHeight);\n                        //\u91cd\u65b0\u8c03\u6574\u4e86\u6ee4\u6ce2\u7684\u8303\u56f4\u548c\u6743\u91cd\uff0c\u51cf\u5c11\u6c34\u6ce2\u7eb9\n                        blurCoordinates[0] = v_texCoord + vec2(0.0, -4.0) * imageStep;\n                        blurCoordinates[1] = v_texCoord + vec2(2.0, -3.0) * imageStep;\n                        blurCoordinates[2] = v_texCoord + vec2(3.0, -2.0) * imageStep;\n                        blurCoordinates[3] = v_texCoord + vec2(4.0, 0.0) * imageStep;\n                        blurCoordinates[4] = v_texCoord + vec2(3.0, 2.0) * imageStep;\n                        blurCoordinates[5] = v_texCoord + vec2(2.0, 3.0) * imageStep;\n                        blurCoordinates[6] = v_texCoord + vec2(0.0, 4.0) * imageStep;\n                        blurCoordinates[7] = v_texCoord + vec2(-2.0, 3.0) * imageStep;\n                        blurCoordinates[8] = v_texCoord + vec2(-3.0, 2.0) * imageStep;\n                        blurCoordinates[9] = v_texCoord + vec2(-4.0, 0.0) * imageStep;\n                        blurCoordinates[10] = v_texCoord + vec2(-3.0, -2.0) * imageStep;\n                        blurCoordinates[11] = v_texCoord + vec2(-2.0, -3.0) * imageStep;\n                        blurCoordinates[12] = v_texCoord + vec2(0.0, -2.0) * imageStep;\n                        blurCoordinates[13] = v_texCoord + vec2(-1.0, -1.0) * imageStep;\n                        blurCoordinates[14] = v_texCoord + vec2(-2.0, 0.0) * imageStep;\n                        blurCoordinates[15] = v_texCoord + vec2(-1.0, 1.0) * imageStep;\n                        blurCoordinates[16] = v_texCoord + vec2(0.0, 2.0) * imageStep;\n                        blurCoordinates[17] = v_texCoord + vec2(1.0, 1.0) * imageStep;\n                        blurCoordinates[18] = v_texCoord + vec2(2.0, 0.0) * imageStep;\n                        blurCoordinates[19] = v_texCoord + vec2(1.0, -1.0) * imageStep;\n                        vec3 sampleColor = centralColor * 24.0;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[0]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[1]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[2]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[3]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[4]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[5]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[6]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[7]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[8]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[9]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[10]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[11]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[12]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[13]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[14]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[15]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[16]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[17]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[18]).rgb;\n                        sampleColor += texture2D(inputImageTexture, blurCoordinates[19]).rgb;\n                        sampleColor = sampleColor/44.0;\n                        float dis = centralColor.g - sampleColor.g + 0.5;\n                        for (int i = 0; i < 5; i++) {\n                            dis = hardLight(dis);\n                        }\n                        // 0.065 -> 1.125, \u52a0\u5927\u6ee4\u6ce2\u5f3a\u5ea6\n                        vec3 result = centralColor * 1.125 - dis * 0.125; //central+(central-dis)*0.065\n                        float hue = dot(result, vec3(0.299,0.587,0.114)) - 0.3;   //luminance\n                        hue = pow(clamp(hue, 0.0, 1.0), 0.3);\n                        yuv= rgb2yuv(sampleColor);\n                        float cr=yuv.y-0.094;\n                        float cb=yuv.z+0.0745;\n                        float tx = ((25.59*cr-19.19*cb)*255.0 + 51.0)*0.04;\n                        float ty = ((25.59*cr+19.19*cb)*255.0 + 77.0)*0.07;\n                        float val0 = tx*tx + ty*ty;\n                        float chroma_sum=yuv.y+yuv.z+1.0;\n                        float chroma_diff=yuv.y-yuv.z;\n                        float chroma_diff_th = 0.1-(yuv.x/10.0);\n                        float face = 1.0;\n                        if(yuv.z>-0.1667 && yuv.z<0.0294 && chroma_sum>0.7804 && chroma_sum<1.098 && chroma_diff>chroma_diff_th) {\n                            if(yuv.x<0.3922) {\n                                if(val0<1700.0) {\n                                    face = 0.0;\n                                } else {\n                                    hue = 0.0;\n                                }\n                            } else {\n                                if(val0<3150.0) {\n                                    face = 0.0;\n                                } else {\n                                    hue = 0.0;\n                                }\n                            }\n                        } else {\n                            hue = 0.0;\n                        }\n                        result = centralColor * (1.0 - hue) + result * hue;\n                        result = result+vec3(brightness*0.1);\n                        // \u8fd9\u91cc\u53ef\u4ee5\u8fdb\u4e00\u6b65\u7b80\u5316\u8ba1\u7b97\n                        if(showMode == 1 /*|| showMode == 2*/) {\n                             result = vec3(hue);\n                        }\n                        else if(showMode == 0) {\n                            result = centralColor;\n                        }\n                        vec3 smoothNew = mix(centralColor, result, smoothDegree);\n                    //showCounter\u7528\u4e8e\u663e\u793amask\n                    if(showCounter == 1) {\n                        smoothNew =vec3(face);\n                    }\n                    //mode3:\u663e\u793a\u8fb9\u7f18\n                    if(showMode == 3) {\n                        vec3 maxValue = maxFilter().rgb;\n                        float lumOrigin = lum(centralColor);\n                        float lumMax = lum(maxValue) + 0.001;\n                        float blendColor = min(lumOrigin / lumMax, 1.0);\n                        float smoothDegree2 =  0.8 + (smoothDegree/5.0); //\u7ea6\u675f\u8303\u56f4\uff1a0.8~1.0\n                        smoothNew =mix(centralColor, vec3(blendColor), smoothDegree2);\n                    }\n                    //mode4:\u663e\u793a\u8f6e\u5ed3\n                    if(showMode == 4) {\n                        vec4 src  = Sobel2();\n                        // saturation\u5408\u5e76\u5230level\u4e2d\n                        max(src.r, src.g);\n                        float lum = (max(max(src.r, src.g),src.b) + min(min(src.r, src.g), src.b)) / 2.0;\n                        src = vec4(mix(vec3(lum), src.rgb, 0.0), src.a);  //intensity = 0.0\n                        // level filter: colorLevel.x = dark = 0.33, colorLevel.y = light = 0.60\n                        float colorLevelx = 0.3;\n                        float colorLevely = 0.60;\n                        //float gamma = 0.99;\n                        float gamma = smoothDegree;\n                        src.rgb = clamp((src.rgb - colorLevelx) / (colorLevely - colorLevelx), 0.0, 1.0);\n                        src.rgb = clamp(pow(src.rgb, vec3(gamma)), 0.0, 1.0);\n                        smoothNew = src.rgb;\n                    }\n                    gl_FragColor = vec4(smoothNew, 1.0);\n                    } "

    invoke-static {v0, v2}, Lcom/tencent/mm/media/k/c$a;->aD(Ljava/lang/String;Ljava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    .line 35
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "a_position"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetAttribLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->gRA:I

    .line 36
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "a_texCoord"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetAttribLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->gRB:I

    .line 37
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "inputImageTexture"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetAttribLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->gRC:I

    .line 38
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "smoothDegree"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetUniformLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->ECK:I

    .line 39
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "showCounter"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetUniformLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->ECL:I

    .line 40
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "showMode"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetUniformLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->ECM:I

    .line 41
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "brightness"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetUniformLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->ECN:I

    .line 42
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "texelWidth"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetUniformLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->ECO:I

    .line 43
    iget v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->programId:I

    const-string/jumbo v2, "texelHeight"

    invoke-static {v0, v2}, Landroid/opengl/GLES20;->glGetUniformLocation(ILjava/lang/String;)I

    move-result v0

    iput v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->ECP:I

    .line 44
    iget-boolean v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->EEs:Z

    if-eqz v0, :cond_0

    .line 45
    new-instance v0, Lcom/tencent/mm/plugin/voip/video/render/EncoderSurfaceRender;

    invoke-direct {v0}, Lcom/tencent/mm/plugin/voip/video/render/EncoderSurfaceRender;-><init>()V

    iput-object v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->EEr:Lcom/tencent/mm/plugin/voip/video/render/EncoderSurfaceRender;

    .line 49
    :goto_0
    const/16 v0, 0x2801

    invoke-static {v8, v0, v9}, Landroid/opengl/GLES20;->glTexParameterf(IIF)V

    .line 50
    const/16 v0, 0x2800

    invoke-static {v8, v0, v9}, Landroid/opengl/GLES20;->glTexParameterf(IIF)V

    .line 51
    const/16 v0, 0x2802

    invoke-static {v8, v0, v10}, Landroid/opengl/GLES20;->glTexParameterf(IIF)V

    .line 52
    const/16 v0, 0x2803

    invoke-static {v8, v0, v10}, Landroid/opengl/GLES20;->glTexParameterf(IIF)V

    .line 53
    invoke-static {v11}, Lcom/tencent/matrix/trace/core/AppMethodBeat;->o(I)V

    return-void

    .line 47
    :cond_0
    new-instance v0, Lcom/tencent/mm/media/j/b/e;

    const/4 v5, 0x2

    const/16 v7, 0x20

    move v2, v1

    move v3, v1

    move v4, v1

    move v6, v1

    invoke-direct/range {v0 .. v7}, Lcom/tencent/mm/media/j/b/e;-><init>(IIIIIII)V

    iput-object v0, p0, Lcom/tencent/mm/plugin/voip/video/c/d;->gRz:Lcom/tencent/mm/media/j/b/e;

    goto :goto_0
.end method
